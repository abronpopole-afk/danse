private async captureScreen(windowHandle: number): Promise<Buffer> {
    logger.debug("GGClubAdapter", `[${windowHandle}] captureScreen - tentative`);
    
    if (screenshotDesktop) {
      try {
        const window = this.activeWindows.get(`ggclub_${windowHandle}`);
        if (window) {
          logger.info("GGClubAdapter", `[${windowHandle}] Capture de la fenêtre: ${window.title}`);
          
          const pngBuffer = await screenshotDesktop({
            screen: window.title,
            format: 'png',
          });
          
          logger.info("GGClubAdapter", `[${windowHandle}] PNG reçu (${pngBuffer.length} bytes), décodage...`);
          
          try {
            // Décoder PNG en RGBA
            const rgbaBuffer = await this.decodePngToRgba(pngBuffer);
            logger.info("GGClubAdapter", `[${windowHandle}] RGBA décodé (${rgbaBuffer.length} bytes)`);
            return rgbaBuffer;
          } catch (decodeError) {
            logger.warn("GGClubAdapter", `[${windowHandle}] Décodage PNG échoué, retourner PNG brut pour traitement alternatif`);
            // Si le décodage fail, retourner quand même le PNG - le pipeline va le gérer
            return pngBuffer;
          }
        }

        logger.warning("GGClubAdapter", `[${windowHandle}] Fenêtre non trouvée`);
        const imgBuffer = await screenshotDesktop({ format: 'png' });
        return imgBuffer;
      } catch (error) {
        logger.error("GGClubAdapter", `[${windowHandle}] Erreur capture`, { error: String(error) });
        return Buffer.alloc(0);
      }
    }

    logger.error("GGClubAdapter", `[${windowHandle}] screenshot-desktop indisponible`);
    return Buffer.alloc(0);
  }

  private async decodePngToRgba(pngBuffer: Buffer): Promise<Buffer> {
    try {
      // Parser PNG pour extraire dimensions + pixel data
      // Format PNG simple: 8 byte signature + chunks
      
      if (pngBuffer.length < 24) throw new Error('PNG buffer too small');
      if (pngBuffer[0] !== 0x89 || pngBuffer[1] !== 0x50 || pngBuffer[2] !== 0x4E || pngBuffer[3] !== 0x47) {
        throw new Error('Invalid PNG signature');
      }
      
      // Lire IHDR chunk (width/height)
      const width = pngBuffer.readUInt32BE(16);
      const height = pngBuffer.readUInt32BE(20);
      const bitDepth = pngBuffer[24];
      const colorType = pngBuffer[25]; // 6 = RGBA
      
      logger.debug("GGClubAdapter", `PNG: ${width}x${height}, bitDepth=${bitDepth}, colorType=${colorType}`);
      
      // Trouver chunk IDAT (image data compressé)
      let offset = 8; // Après signature
      let idatData: Buffer[] = [];
      
      while (offset < pngBuffer.length - 12) {
        const chunkLength = pngBuffer.readUInt32BE(offset);
        const chunkType = pngBuffer.toString('ascii', offset + 4, offset + 8);
        
        if (chunkType === 'IDAT') {
          const chunkData = pngBuffer.slice(offset + 8, offset + 8 + chunkLength);
          idatData.push(chunkData);
        }
        
        offset += 12 + chunkLength; // 4 (length) + 4 (type) + data + 4 (crc)
      }
      
      if (idatData.length === 0) {
        throw new Error('No IDAT chunk found');
      }
      
      // Combiner tous les IDAT chunks
      const compressedData = Buffer.concat(idatData);
      
      // Décompresser avec zlib
      const zlib = require('zlib');
      const pixelData = await new Promise<Buffer>((resolve, reject) => {
        zlib.inflate(compressedData, (err: any, result: Buffer) => {
          if (err) reject(err);
          else resolve(result);
        });
      });
      
      logger.debug("GGClubAdapter", `Décompressé: ${pixelData.length} bytes`);
      
      // Convertir pixel data en RGBA
      // PNG pixel data = scanlines avec filtres
      const scanlineLength = width * (colorType === 6 ? 4 : colorType === 2 ? 3 : 1) + 1; // +1 pour byte de filtre
      const rgbaBuffer = Buffer.alloc(width * height * 4);
      
      let pixelIdx = 0;
      let rgbaIdx = 0;
      
      for (let y = 0; y < height; y++) {
        const filterType = pixelData[pixelIdx++]; // Ignorer pour simplifier
        
        for (let x = 0; x < width; x++) {
          if (colorType === 6) {
            // RGBA
            const r = pixelData[pixelIdx++];
            const g = pixelData[pixelIdx++];
            const b = pixelData[pixelIdx++];
            const a = pixelData[pixelIdx++];
            rgbaBuffer[rgbaIdx++] = r;
            rgbaBuffer[rgbaIdx++] = g;
            rgbaBuffer[rgbaIdx++] = b;
            rgbaBuffer[rgbaIdx++] = a;
          } else if (colorType === 2) {
            // RGB
            const r = pixelData[pixelIdx++];
            const g = pixelData[pixelIdx++];
            const b = pixelData[pixelIdx++];
            rgbaBuffer[rgbaIdx++] = r;
            rgbaBuffer[rgbaIdx++] = g;
            rgbaBuffer[rgbaIdx++] = b;
            rgbaBuffer[rgbaIdx++] = 255;
          } else {
            // Greyscale ou autre
            const gray = pixelData[pixelIdx++];
            rgbaBuffer[rgbaIdx++] = gray;
            rgbaBuffer[rgbaIdx++] = gray;
            rgbaBuffer[rgbaIdx++] = gray;
            rgbaBuffer[rgbaIdx++] = 255;
          }
        }
      }
      
      return rgbaBuffer;
    } catch (error) {
      logger.error("GGClubAdapter", `PNG decode error`, { error: String(error) });
      throw error;
    }
  }